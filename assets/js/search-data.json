{
  
    
        "post0": {
            "title": "Integral Numérica - Método de Simpson Composto",
            "content": "M&#233;todo de Simpson Composto . A regra de Simpson baseia-se em aproximar a integral definida pela área sob arcos de parábola que interpolam a função. Origem: Wikipédia . . Formula&#231;&#227;o do M&#233;todo . n:Intervalos Igualmente Espaçados&gt; OBS:A medida que o valor de n aumenta a integração de f(x) tende ao valor real . $$h = dfrac{x_m - x_0}{n}$$ . $$ int_{a}^{b} f(x) ,dx approx dfrac{1}{3}h {[f(x_0) + f(x_m)] +4[f(x_1)+ $$ $$ f(x_3) + dots + f(x_{m-1})] + 2[f(x_2) + f(x_4)+ dots + f(x_{m-2}) ] }$$ . ou . $${ displaystyle { begin{aligned} int _{a}^{b}f(x) ,dx&amp; approx { frac {h}{3}} sum _{j=1}^{n/2}{ big [}f(x_{2j-2})+4f(x_{2j-1})+f(x_{2j}){ big ]} &amp;={ frac {h}{3}}{ bigg [}f(x_{0})+2 sum _{j=1}^{n/2-1}f(x_{2j})+4 sum _{j=1}^{n/2}f(x_{2j-1})+f(x_{n}){ bigg ]}, end{aligned}}}$$ . . Implementa&#231;&#227;o do Algor&#237;timo em Python . Biblioteca Python . Importando a Biblioteca Python que será usada no código. . import numpy as np . C&#243;digo Python . Código para integração numérica usando o Método de Simpson Composto. . Onde: . [x_0] Limite inferior | [x_m] Limite superior | [ f ] função que será integrada | [ n ] sub-intervalos - OBS:Tem que ser um valor PAR | . def metodo_simpson(f, x_0, x_m, n): # O passo de integração, n é a quantidade de subintervalos que queremos. # veridicando se [n] é PAR, condição necessária para o método simpson. if (n%2 != 0): n -= 1 h = (x_m - x_0)/ float(n) f_x0 = f(x_0) f_xm = f(x_m) x = x_0 x += h index = 1 somatorio = 0.0 while (x &lt; x_m): if (index%2 != 0): somatorio += 4*f(x) else: somatorio += 2*f(x) index += 1 x += h integral = (h /3.0)*(f_x0 + f_xm + somatorio) print(&#39; n***************************&#39;+&#39; 033[1m&#39;+ &#39; SAÍDA &#39; + &#39; 033[0m&#39;+&#39;*************************** n&#39;) print(f&quot; tIntegral ≈ {integral}&quot;) print(f&quot; tSubintervalos [n] = {n}&quot;) print(f&quot; tPasso [h] = {h}&quot;) print(f&quot; tLimite Inferior [x_0] = {x_0}&quot;) print(f&quot; tLimite Superior [x_m] = {x_m}&quot;) print(&quot; n************************************************************* n&quot;) . . Exemplo 01 . Aplicando o Método de Simpsom Composto ao exemplo abaixo, temos: . $$ int_{x_0}^{x_m} 2x-e^x ,dx$$ . $$ int_{-1}^{2} 2x-e^x ,dx approx dfrac{1}{3}h {[2x_0-e^{x_0} + 2x_m-e^{x_m}] + $$ . $$4[2x_1-e^{x_1} + 2x_3-e^{x_3} + dots + 2x_{m-1}-e^{x_{m-1}}] + $$ . $$2[2x_2-e^{x_2} + 2x_4-e^{x_4}+ dots + 2x_{m-2}-e^{x_{m-2}} ] }$$ . . Código . f = lambda x: 2*x-np.exp(x) # Resolvendo a integral usando o método de simpson composto x_0 = 0; x_m = 2; n = 10 metodo_simpson(f, x_0, x_m, n) . *************************** SAÍDA *************************** Integral ≈ -2.840986767759475 Subintervalos [n] = 10 Passo [h] = 0.2 Limite Inferior [x_0] = 0 Limite Superior [x_m] = 2 ************************************************************* . . Exemplo 02 . Aplicando o Método de Simpsom Composto ao exemplo abaixo, temos: . $$ int_{a}^{b} cos(x) ,dx$$ . $$ int_{a}^{b} 2x-e^x ,dx approx dfrac{1}{3}h {[cos(x_0) + cos(x_m)] + $$ . $$4[cos(x_1) + cos(x_3) + dots + cos(x_{m-1})] + $$ . $$2[cos(x_2) + cos(x_4)+ dots + cos(x_{m-2}) ] }$$ . . Código . f = lambda x: np.cos(x) # Resolvendo a integral usando o método de simpson composto x_0 = 0; x_m = 2; n = 10 metodo_simpson(f, x_0, x_m, n) . *************************** SAÍDA *************************** Integral ≈ 0.85381930324762 Subintervalos [n] = 10 Passo [h] = 0.2 Limite Inferior [x_0] = 0 Limite Superior [x_m] = 2 ************************************************************* . . Exemplo 03: . Aplicando o Método de Simpsom Composto ao exemplo abaixo, temos: . $$ int_{a}^{b} x^2 ,dx$$ . $$ int_{a}^{b} x^2 ,dx approx dfrac{1}{3}h {[x_0^2 + x_m^2] + 4[x_1^2 + x_3^2 + dots + x_{m-1}^2] + $$ . $$2[x_2^2 + x_4^2 + dots + x_{m-2}^2 ] }$$ . . Código . f = lambda x: x**2 # Resolvendo a integral usando o método de simpson composto x_0 = 0; x_m = 2; n = 10 metodo_simpson(f, x_0, x_m, n) . *************************** SAÍDA *************************** Integral ≈ 3.2 Subintervalos [n] = 10 Passo [h] = 0.2 Limite Inferior [x_0] = 0 Limite Superior [x_m] = 2 ************************************************************* .",
            "url": "https://oseiasdfarias.github.io/jupyter-notebooks/jupyter/calculo%20numerico/python/2022/02/25/integral-numerica-simpson-composto.html",
            "relUrl": "/jupyter/calculo%20numerico/python/2022/02/25/integral-numerica-simpson-composto.html",
            "date": " • Feb 25, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Transformações de Sinais",
            "content": "Podemos transformar um sinal de direfentes maneiras, para um sinal x(t) podemos variar sua amplitude quando multiplicamos por uma constante $K$, desde que essa constante seja positiva e maior que 1, temos as seguintes transformações. . $$x(t) cdot u(t)$$ . Amplificando o sinal: . $$y(t) = K cdot x(t) cdot u(t) : : k&gt;1$$ . Atenuando o sinal: . $$y(t) = K cdot x(t) cdot u(t) : : 0&lt;k&lt;1$$ . Caso o sinal seja multiplicado por um valor negativo, seus valores serão espelhados no eixo X . $$x(t) cdot u(t)$$ . Amplificando e espelhando o sinal: . $$y(t) = K cdot x(t) cdot u(t) : : k&gt;1$$ . Atenuando e espenhando o sinal: . $$y(t) = K cdot x(t) cdot u(t) : : 0&lt;k&lt;1$$ . Amplificando e atenunado um sinal com valores positivos para K: . Sinal Original: $$x(t)=(5-t) cdot u(t)$$ . | Sinal Amplificado: . | . Multiplicando o sinal por um valor de k=1,5 $$x(t)=1,5 cdot (5-t) cdot u(t)$$ . Sinal Atenuado: | . Multiplicando o sinal por um valor de k=0,5 $$x(t) = 0,5 cdot (5-t) cdot u(t)$$ . C&#243;digo para visualiza&#231;&#227;o dos Sinais Transformados . import numpy as np import matplotlib.pyplot as plt plt.style.use(&#39;seaborn&#39;) %matplotlib inline . t = np.linspace(-3, 5, 100) # Degrau unitário u = [] for i in t: if i &lt;= 0: u.append(0) else: u.append(1) u = np.array(u) # Sinal Original y = (5-t) def transformacao_sinal(y, u, t, k = [1, 1, 1]): yu = y*u fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 6)) plt.subplots_adjust(top=0.85) plt.suptitle(&quot;Aplicando Transformações no sinal $x(t) = 5-t$&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax1.plot(t, k[0]*yu, label=&quot;Sinal $x(t) = (5-t) cdot u(t)$&quot;, lw=3) ax1.plot(t, y,&quot;--&quot;, label=&quot;Sinal $x(t) = (5-t)$&quot;, color=&quot;black&quot;, lw=1.5) ax1.plot(t, u, &quot;*&quot;, label=&quot;Sinal $Degrau : u(t)$&quot;, lw=1.2) ax1.legend() ax1.axhline(0, color=&quot;black&quot;, lw=1.2) ax1.axvline(0, color=&quot;black&quot;, lw=1.2) if k[1] &gt; 0: ax1.set_yticks(range(0, 9)) else: ax1.set_yticks(range(-9, 9)) ax1.set_title(f&quot;Função $x(t)=(5-t)$ - Sinal Original&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax1.set_xlabel(&quot;Tempo $(t)$&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) ax1.set_ylabel(&quot;Amplitude&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) # Amplificando o sinal, Multiplicando o sinal por um valor mair que 1. y1 = y; y1u = k[1]*y1*u ax2.plot(t, y1u, label=&quot;Sinal $x(t) = 1,5 cdot (5-t) cdot u(t)$&quot;, lw=3) ax2.plot(t, y1,&quot;--&quot;, color=&quot;black&quot;, label=&quot;Sinal $x(t) = 1,5 cdot (5-t)$&quot;, lw=1.5) ax2.plot(t, u, &quot;*&quot;, label=&quot;Sinal $Degrau : u(t)$&quot;, lw=1.2) ax2.legend() ax2.axhline(0, color=&quot;black&quot;, lw=1.2) ax2.axvline(0, color=&quot;black&quot;, lw=1.2) ax2.set_xticks(range(-3, 6)) if k[0] &gt; 0: ax2.set_yticks(range(0, 9)) else: ax2.set_yticks(range(-9, 9)) ax2.set_title(f&quot;Função $x(t)=1,5 cdot(5-t)$ - Sinal Amplificado por 1,5&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax2.set_xlabel(&quot;Tempo $(t)$&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) ax2.set_ylabel(&quot;Amplitude&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) # atenuando o sinal, Multiplicando o sinal por um valor menor que 1. y2 = y; y2u = k[2]*y2*u ax3.plot(t, y2u, label=&quot;Sinal $x(t) = 0,5 cdot (5-t) cdot u(t)$&quot;, lw=3) ax3.plot(t, y2,&quot;--&quot;, color=&quot;black&quot;, label=&quot;Sinal $x(t) = 0,5 cdot (5-t)$&quot;, lw=1.5) ax3.plot(t, u, &quot;*&quot;, label=&quot;Sinal $Degrau : u(t)$&quot;, lw=1.2) ax3.legend() ax3.axhline(0, color=&quot;black&quot;, lw=1.2) ax3.axvline(0, color=&quot;black&quot;, lw=1.2) if k[0] &gt; 0: ax3.set_yticks(range(0, 9)) else: ax3.set_yticks(range(-9, 9)) ax3.set_title(f&quot;Função $x(t)=0,5 cdot(5-t)$ - Sinal Atenuado por 0,5&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax3.set_xlabel(&quot;Tempo $(t)$&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) ax3.set_ylabel(&quot;Amplitude&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) plt.show() . transformacao_sinal(y, u, t, k=[1, 1.5, 0.5]) . Espelhando, Amplificando e atenunado um sinal com valores negativos para K: . Sinal Original: $$x(t)=-(5-t) cdot u(t)$$ . | Sinal Amplificado e Espelhado no eixo X: . | . Multiplicando o sinal por um valor de k=-1,5 $$x(t)= -1,5 cdot (5-t) cdot u(t)$$ . Sinal Atenuado e Espelhado no eixo X: | . Multiplicando o sinal por um valor de k=-0,5 $$x(t) = -0,5 cdot (5-t) cdot u(t)$$ . C&#243;digo para visualiza&#231;&#227;o dos Sinais Transformados . transformacao_sinal(y, u, t, k=[-1, -1.5, -0.5]) . Deslocando o sinal no eixo Y . Se somar uma constante ao sinal, caso o valor for positivo o sinal é deslocando no eixo Y positivamente, do contrário o sinal será deslocado na direção negativa do eixo Y: . Sinal Original: $$x(t)=-(5-t) cdot u(t)$$ . | Sinal Deslocado positivamente no eixo Y: . | . Somando um valor positivo ao sinal x(t). $$x(t)= (5-t) + 2 cdot u(t)$$ . Sinal Deslocado negativamente no eixo Y: | . Somando um valor negativo ao sinal x(t). $$x(t) = (5-t) + (-2) cdot u(t)$$ . def transformacao_sinal2(y, u, t): yu = y*u fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 6)) plt.subplots_adjust(top=0.85) plt.suptitle(&quot;Aplicando Transformações no sinal $x(t) = 5-t$&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax1.plot(t, yu, label=&quot;Sinal $x(t) = (5-t) cdot u(t)$&quot;, lw=3) ax1.plot(t, y,&quot;--&quot;, label=&quot;Sinal $x(t) = (5-t)$&quot;, color=&quot;black&quot;, lw=1.5) ax1.plot(t, u, &quot;-.&quot;, color=&quot;black&quot;, label=&quot;Sinal $Degrau : u(t)$&quot;, lw=1.2) ax1.legend() ax1.axhline(0, color=&quot;black&quot;, lw=1.2) ax1.axvline(0, color=&quot;black&quot;, lw=1.2) ax1.set_yticks(range(-9, 9)) ax1.set_title(f&quot;$x(t)=(5-t)$ - Sinal Original&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax1.set_xlabel(&quot;Tempo $(t)$&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) ax1.set_ylabel(&quot;Amplitude&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) # Amplificando o sinal, Multiplicando o sinal por um valor mair que 1. y1u = y * u + 2 ax2.plot(t, y1u, label=&quot;Sinal $x(t) = (5-t) + 2 cdot u(t)$&quot;, lw=3) ax2.plot(t, y,&quot;--&quot;, color=&quot;black&quot;, label=&quot;Sinal $x(t) = (5-t)$&quot;, lw=1.5) ax2.plot(t, u, &quot;-.&quot;, color=&quot;black&quot;, label=&quot;Sinal $Degrau : u(t)$&quot;, lw=1.2) ax2.legend() ax2.axhline(0, color=&quot;black&quot;, lw=1.2) ax2.axvline(0, color=&quot;black&quot;, lw=1.2) ax2.set_xticks(range(-3, 6)) ax2.set_yticks(range(-9, 9)) ax2.set_title(f&quot;$x(t)=(5-t) + 2$ - Deslocamento Positivo em Y&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax2.set_xlabel(&quot;Tempo $(t)$&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) ax2.set_ylabel(&quot;Amplitude&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) # atenuando o sinal, Multiplicando o sinal por um valor menor que 1. y2u = y*u-2 ax3.plot(t, y2u, label=&quot;Sinal $x(t) = (5-t) - 2 cdot u(t)$&quot;, lw=3) ax3.plot(t, y,&quot;--&quot;, color=&quot;black&quot;, label=&quot;Sinal $x(t) = (5-t)$&quot;, lw=1.5) ax3.plot(t, u, &quot;-.&quot;, color=&quot;black&quot;, label=&quot;Sinal $Degrau : u(t)$&quot;, lw=1.2) ax3.legend() ax3.axhline(0, color=&quot;black&quot;, lw=1.2) ax3.axvline(0, color=&quot;black&quot;, lw=1.2) ax3.set_yticks(range(-9, 9)) ax3.set_title(f&quot;$x(t )= (5-t) - 2$ - Deslocamento Negativo em Y&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax3.set_xlabel(&quot;Tempo $(t)$&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) ax3.set_ylabel(&quot;Amplitude&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) plt.show() . transformacao_sinal2(y, u, t) . . Transforma&#231;&#245;es no Argumento de $x(t) rightarrow x( alpha t + beta)$ . Quando a transformação é no argumento da função x(t) o sinal sofre mudanças no eixo do tempo. dependendo dos valores de $ alpha $ e de $ beta$, o sinal sofrerá diferentes transformações: . Transformações no Argumento: $$x( alpha t + beta)$$ | . Aplicando Transforma&#231;&#245;es no Argumento: . 01 - Deslocamento no Tempo . Para que um sinal seja deslocado no tempo, sem sofrer mudanças na frequência, deve-se aplicar os seguintes valores para $ alpha$ e $ beta$: . $$ alpha = 1 : : : : beta neq 0$$ . $$x(t) = begin{cases} 0 &amp; text{$ t lt 0 $} 1 &amp; text{0 &lt; t $ le 1$} 2 - t &amp; text{$1 lt t lt 2$} 0 &amp; text{$ t lt 2 $} end{cases}$$ Gráfico da Função x(t): . t0 = np.linspace(-1, 0, 10) t1 = np.linspace(0, 1, 10) t2 = np.linspace(1, 2, 10) t3 = np.linspace(2, 3, 10) x0 = np.zeros_like(t0) x1 = np.ones_like(t1) x2 = 2 - t2 x3 = np.zeros_like(t3) tt = np.concatenate((t0, t1, t2, t3), axis=None) xt = np.concatenate((x0, x1, x2, x3), axis=None) fig1, ax = plt.subplots(1, figsize=(10, 5)) ax.plot(tt, xt, color=&quot;blue&quot;, lw=2) ax.axhline(0, color=&quot;black&quot;, lw=1.2) ax.axvline(0, color=&quot;black&quot;, lw=1.2) ax.set_yticks(range(-1, 3)) ax.set_title(f&quot;$x(t)$ - Sinal Original&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax.set_xlabel(&quot;Tempo $(t)$&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) ax.set_ylabel(&quot;Amplitude&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) plt.show() . Atrazando o sinal x(t) . Para atrazar o sinal x(t), é preciso subtrair do argumento um valor, assim temos que $ beta$ tem que ser negativo, como mostra o exemplo abaixo: . $$x( alpha t + beta) : : : rightarrow beta lt 0 : : : text{atraso}$$ . Gráfico da Função x(t): . $$ alpha = 1 : : : : beta = text{-0,5}$$ . $$x( alpha t -0,5) = begin{cases} 0 &amp; text{$ t lt 0,5 $} 1 &amp; text{0,5 &lt; t $ le 1,5$} 2 - t &amp; text{$1,5 lt t lt 2,5$} 0 &amp; text{$ t lt 2,5 $} end{cases}$$ t01 = np.linspace(-0.5, 0.5, 10) t11 = np.linspace(0.5, 1.5, 10) t21 = np.linspace(1.5, 2.5, 10) t31 = np.linspace(2.5, 3.5, 10) x01 = np.zeros_like(t01) x11 = np.ones_like(t11) x21 = 2.5 - t21 x31 = np.zeros_like(t31) tt2 = np.concatenate((t01, t11, t21, t31), axis=None) xt2 = np.concatenate((x01, x11, x21, x31), axis=None) fig2, ax2 = plt.subplots(1, figsize=(10, 5)) ax2.plot(tt, xt, &quot;-.&quot;, color=&quot;blue&quot;, lw=2) ax2.plot(tt2, xt2, color=&quot;black&quot;, lw=2) ax2.axhline(0, color=&quot;black&quot;, lw=1.2) ax2.axvline(0, color=&quot;black&quot;, lw=1.2) ax2.set_yticks(range(-1, 3)) ax2.set_title(f&quot;$x(t)$ - Sinal Original&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax2.set_xlabel(&quot;Tempo $(t)$&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) ax2.set_ylabel(&quot;Amplitude&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) plt.show() . Adiantando o sinal x(t) . Para adiantar o sinal x(t), é preciso somar no argumento um valor, assim temos que $ beta$ tem que ser positivo, como mostra o exemplo abaixo: . $$x( alpha t + beta) : : : rightarrow beta &gt; 0 : : : text{adiantado}$$ . Gráfico da Função x(t): . $$ alpha = 1 : : : : beta = text{0,5}$$ . $$x( alpha t + 0,5) = begin{cases} 0 &amp; text{$ t lt -0,5 $} 1 &amp; text{-0,5 &lt; t $ le 0,5$} 2 - t &amp; text{$0,5 lt t lt 1,5$} 0 &amp; text{$ t lt 1,5 $} end{cases}$$ t02 = np.linspace(-1, -0.5, 10) t12 = np.linspace(-0.5, 0.5, 10) t22 = np.linspace(0.5, 1.5, 10) t32 = np.linspace(1.5, 2.5, 10) x02 = np.zeros_like(t02) x12 = np.ones_like(t12) x22 = 1.5 - t22 x32 = np.zeros_like(t32) tt2 = np.concatenate((t02, t12, t22, t32), axis=None) xt2 = np.concatenate((x02, x12, x22, x32), axis=None) fig2, ax2 = plt.subplots(1, figsize=(10, 5)) ax2.plot(tt, xt, &quot;-.&quot;, color=&quot;blue&quot;, lw=2) ax2.plot(tt2, xt2, color=&quot;black&quot;, lw=2) ax2.axhline(0, color=&quot;black&quot;, lw=1.2) ax2.axvline(0, color=&quot;black&quot;, lw=1.2) ax2.set_yticks(range(-1, 3)) ax2.set_title(f&quot;$x(t)$ - Sinal Original&quot;, fontweight=&quot;medium&quot;, fontsize = 14) ax2.set_xlabel(&quot;Tempo $(t)$&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) ax2.set_ylabel(&quot;Amplitude&quot;, color=&quot;black&quot;, fontweight=&quot;medium&quot;, fontsize = 12) plt.show() .",
            "url": "https://oseiasdfarias.github.io/jupyter-notebooks/jupyter/analise%20de%20sistemas%20lineares/transforma%C3%A7%C3%B5es%20de%20sinais/python/2022/02/25/Transformac%C3%B5es-de-Sinais.html",
            "relUrl": "/jupyter/analise%20de%20sistemas%20lineares/transforma%C3%A7%C3%B5es%20de%20sinais/python/2022/02/25/Transformac%C3%B5es-de-Sinais.html",
            "date": " • Feb 25, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Integral Numérica - Método do Trapézio Composto",
            "content": "M&#233;todo do Trap&#233;zio Composto . Regra dos Trap&#233;zios &#8211; Defini&#231;&#245;es . Numericamente a regra dos trapézios é obtida aproximando-se f(x) por um polinômio interpolador de 1° grau. | Em seguida calcula-se a área do trapézio cuja base está sobre o eixo dos x. | . . Origem: Pag(12) . Regra dos Trapézios – Dedução da Fórmula . Teorema . Se f(x) for uma função continua em (a, b) onde a é o limite inferior de integração e b o limite superior de integração, A regra do Trapézio composta que podemos usar para aproximar $ int_{a}^{b} f(x) ,dx $ é dada por: . n:Intervalos Igualmente Espaçados . $$h = dfrac{b-a}{n}$$ . $$ int_{a}^{b} f(x) ,dx approx dfrac{1}{2}h(f(a) + 2[f(x_1) + f(x_2) +$$ . $$ dots + f(x_{n-1})] + f(b))$$ . . . Implementa&#231;&#227;o do Algor&#237;timo em Python . Biblioteca Python . Importando as Biblioteca Python que será usada no código. . import numpy as np . C&#243;digo Python . Código para integração numérica usando o Método do Trapézio. . Onde: . [a] Limite inferior | [b] Limite superior | [n] sub-intervalos | [f ] função que será integrada | . def integ_trap(f, a, b, n): # O passo de integração, n é a quantidade de subintervalos que queremos. h = (b-a)/ float(n) f_a = f(a) x = a x += h somatorio = 0.0 while (x &lt; b): somatorio += 2*f(x) x += h f_b = f(b) integral_trap = (h /2.0)*(f_a + somatorio + f_b) print(&#39; n***************************&#39;+&#39; 033[1m&#39;+ &#39; SAÍDA &#39; + &#39; 033[0m&#39;+&#39;*************************** n&#39;) print(f&quot; tIntegral ≈ {integral_trap}&quot;) print(f&quot; tSubintervalos [n] = {n}&quot;) print(f&quot; tPasso [h] = {h}&quot;) print(f&quot; tLimite Inferior [a] = {a}&quot;) print(f&quot; tLimite Superior [b] = {b}&quot;) print(&quot; n************************************************************* n&quot;) . . Exemplo 01 . Aplicando o Método do Trapézio ao exemplo abaixo, temos: . $$ int_{0}^{2} cos(x) ,dx$$ . . $$ int_{a}^{b} cos(x) ,dx approx dfrac{1}{2}h(cos(x) + 2[cos(x_1) + cos(x_2) +$$ . $$ dots + cos(x_{n-1})] + cos(b))$$ . . Código . f = lambda x: np.cos(x) # Aplicando a integral usando o método do trapézio a = 0; b = 2; n = 100000 integ_trap(f, a, b, n) . *************************** SAÍDA *************************** Integral ≈ 0.9092891038599877 Subintervalos [n] = 100000 Passo [h] = 2e-05 Limite Inferior [a] = 0 Limite Superior [b] = 2 ************************************************************* . . Exemplo 02 . Aplicando o Método do Trapézio ao exemplo abaixo, temos: . $$ int_{0}^{2} 2x - e^x ,dx$$ . . $$ int_{a}^{b} 2 e^x ,dx approx dfrac{1}{2}h(2 e^a + 2[2 e^{x_1} + 2 e^{x_2} + $$ . $$ dots + 2 e^x_{n-1}] + 2 e^b)$$ . . Código . f = lambda x: 2*x-np.exp(x) # Aplicando a integral usando o método do trapézio a = 0; b = 2; n = 10000 integ_trap(f, a, b, n) . *************************** SAÍDA *************************** Integral ≈ -2.389733931446894 Subintervalos [n] = 10000 Passo [h] = 0.0002 Limite Inferior [a] = 0 Limite Superior [b] = 2 ************************************************************* . . Exemplo 03 . Aplicando o Método do Trapézio ao exemplo abaixo, temos: . $$ int_{0}^{2} x^2 ,dx$$ . . $$ int_{a}^{b} x^2 ,dx approx dfrac{1}{2}h(a^2 + 2[x_1^2 + x_2^2 +$$ . $$ dots + x_{n-1}^2] + b^2)$$ . . Código . f = lambda x: x**2 # Aplicando a integral usando o método do trapézio a = 0; b = 2; n = 1000 integ_trap(f, a, b, n) . *************************** SAÍDA *************************** Integral ≈ 2.666668000000003 Subintervalos [n] = 1000 Passo [h] = 0.002 Limite Inferior [a] = 0 Limite Superior [b] = 2 ************************************************************* .",
            "url": "https://oseiasdfarias.github.io/jupyter-notebooks/jupyter/2022/02/23/integral-numerica-trapezio-composto.html",
            "relUrl": "/jupyter/2022/02/23/integral-numerica-trapezio-composto.html",
            "date": " • Feb 23, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "Sobre",
          "content": "Acadêmico de Engenharia Elétrica | Machine Learning &amp; Deep Learning | Python | Drone UAVs | .",
          "url": "https://oseiasdfarias.github.io/jupyter-notebooks/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://oseiasdfarias.github.io/jupyter-notebooks/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}